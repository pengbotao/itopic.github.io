<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Python基础语法 - 老彭的博客</title>
    <link rel="stylesheet" href="/static/css/markdown.css">
    <script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0f0111c99240380ee020030f3be990f5";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    </script>
</head>
<body>
<h1 class="title">Python基础语法</h1>
<a href="/"><img src="/static/img/arrow-back.png" class="title_arrow_back" /></a>

<nav>
<ul>
<li><a href="#一-数据类型">一、数据类型</a>
<ul>
<li><a href="#1-1-数值类型-number">1.1 数值类型 - Number</a></li>
<li><a href="#1-2-字符串-str">1.2 字符串 - str</a></li>
</ul></li>
<li><a href="#二-控制流">二、控制流</a>
<ul>
<li><a href="#2-1-if语句">2.1 if语句</a></li>
<li><a href="#2-2-while语句">2.2 while语句</a></li>
<li><a href="#2-3-for语句">2.3 for语句</a></li>
</ul></li>
<li><a href="#三-数据结构">三、数据结构</a>
<ul>
<li><a href="#3-1-列表-list">3.1 列表 - list</a></li>
<li><a href="#3-2-元祖-tuple">3.2 元祖 - tuple</a></li>
<li><a href="#3-3-字典-dict">3.3 字典 - dict</a></li>
<li><a href="#3-4-集合-set">3.4 集合 - set</a></li>
</ul></li>
<li><a href="#四-类型总结">四、类型总结</a>
<ul>
<li><a href="#4-1-类型对比">4.1 类型对比</a></li>
<li><a href="#4-2-类型转换">4.2 类型转换</a></li>
</ul></li>
<li><a href="#五-函数">五、函数</a>
<ul>
<li><a href="#5-1-函数定义">5.1 函数定义</a></li>
<li><a href="#5-2-函数参数-可变参数与关键字参数">5.2 函数参数 - 可变参数与关键字参数</a></li>
<li><a href="#5-3-函数返回">5.3 函数返回</a></li>
<li><a href="#5-4-函数调用">5.4 函数调用</a></li>
<li><a href="#5-5-函数装饰器">5.5 函数装饰器</a></li>
</ul></li>
<li><a href="#六-类-class">六、类 - Class</a>
<ul>
<li><a href="#6-1-类定义">6.1 类定义</a></li>
<li><a href="#6-2-包与导入">6.2 包与导入</a></li>
</ul></li>
<li><a href="#七-错误和异常">七、错误和异常</a></li>
<li><a href="#八-高级用法">八、高级用法</a>
<ul>
<li><a href="#8-1-三元表达式">8.1 三元表达式</a></li>
<li><a href="#8-2-推导式">8.2. 推导式</a></li>
</ul></li>
</ul>
</nav>

<h1 id="一-数据类型">一、数据类型</h1>

<h2 id="1-1-数值类型-number">1.1 数值类型 - Number</h2>

<ul>
<li>int（有符号整型）</li>
<li>long（长整型，Python3去掉）</li>
<li>float（浮点数）</li>
<li>complex（复数）</li>
</ul>

<h2 id="1-2-字符串-str">1.2 字符串 - str</h2>

<p>可以使用单引号或者双引号来创建字符串，如：</p>

<pre><code>&gt;&gt;&gt; a = &quot;Hello World&quot;
&gt;&gt;&gt; b = 'iTopic.org'
</code></pre>

<p><strong>Python中文档查看方法：</strong></p>

<p>命令行中可以通过<code>dir(str)</code>查看字符串支持的方法：</p>

<pre><code>&gt;&gt;&gt; dir(str)
['...', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find',
 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper',
 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust',
 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
 'title', 'translate', 'upper', 'zfill']
</code></pre>

<p>查看对应函数的说明文档：</p>

<pre><code>&gt;&gt;&gt; print(str.find.__doc__)
S.find(sub [,start [,end]]) -&gt; int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.

&gt;&gt;&gt; help(str.join)
</code></pre>

<p><strong>字符串常用操作:</strong></p>

<p><strong>1. 字符串格式化</strong></p>

<pre><code># 字符串拼接
&gt;&gt;&gt; &quot;Hello world &quot; + &quot;2019&quot;
'Hello world 2019'
# 字符串包含变量
&gt;&gt;&gt; &quot;Hello %s %d&quot; % (&quot;world&quot;, 2019)
'Hello world 2019'
# 字符串占位符
&gt;&gt;&gt; &quot;Hello {0} {1}&quot;.format(&quot;world&quot;, 2019)
'Hello world 2019'
# 字符串拼接
&gt;&gt;&gt; ' '.join([&quot;Hello world&quot;, &quot;2019&quot;])
'Hello world 2019'
</code></pre>

<p><strong>2. 字符串去掉两侧空白字符</strong></p>

<pre><code>&gt;&gt;&gt; s = &quot;Hello world 2019 &quot;
# 去掉两侧字符
&gt;&gt;&gt; s.strip()
'Hello world 2019'
# 去掉左侧字符
&gt;&gt;&gt; s.lstrip(&quot;H&quot;)
'ello world 2019 '
# 去掉右侧字符
&gt;&gt;&gt; s.rstrip(&quot; 2019 &quot;)
'Hello world'
</code></pre>

<p><strong>3. 字符串分隔</strong></p>

<pre><code># 字符串分隔
&gt;&gt;&gt; fruits = &quot;apple, orange, banana&quot;
&gt;&gt;&gt; fruits.split(&quot;, &quot;)
['apple', 'orange', 'banana']

# 字符串拼接
&gt;&gt;&gt; &quot;-&quot;.join([&quot;Hello&quot;, &quot;World&quot;])
'Hello-World'
</code></pre>

<p><strong>4. 字符串替换</strong></p>

<pre><code>&gt;&gt;&gt; s = &quot;Hello 2019.&quot;
&gt;&gt;&gt; s.replace(&quot;2019&quot;, &quot;2020&quot;)
'Hello 2020.'
</code></pre>

<p><strong>5. 判断前缀、后缀</strong></p>

<pre><code># 判断前缀
&gt;&gt;&gt; s = &quot;Hello 2019.&quot;
&gt;&gt;&gt; s.startswith(&quot;Hello&quot;)
True

# 判断后缀
&gt;&gt;&gt; s.endswith(&quot;.&quot;)
True
&gt;&gt;&gt; s.endswith(&quot;2019&quot;)
False
</code></pre>

<p><strong>6. 字符串比较</strong></p>

<pre><code># 内置函数cmp比较
&gt;&gt;&gt; a = &quot;Hello&quot;
&gt;&gt;&gt; b = &quot;hello&quot;
&gt;&gt;&gt; cmp(a, b)
-1
</code></pre>

<h1 id="二-控制流">二、控制流</h1>

<h2 id="2-1-if语句">2.1 if语句</h2>

<pre><code>fruits = &quot;apple&quot;

if fruits == &quot;apple&quot;:
    print(&quot;it's an apple&quot;)
elif fruits == &quot;orange&quot;:
    print(&quot;it's an orange&quot;)
else:
    print(&quot;other&quot;)
</code></pre>

<p><code>Python</code>不支持<code>switch</code>语句。</p>

<h2 id="2-2-while语句">2.2 while语句</h2>

<pre><code>i = 0
while i &lt; 10:
    print(i)
    i += 2
    # break
else:
    print(&quot;else i = %d &quot; % i)
</code></pre>

<p>Python中while语句可以带一个else语句，当循环正常结束时执行，需要注意通过break结束的循环不会执行else语句。</p>

<h2 id="2-3-for语句">2.3 for语句</h2>

<pre><code>for i in range(0, 10, 1):
    print(i)
</code></pre>

<p>示例中range可以理解成<code>(i = 0; i &lt;10; i++)</code>，同时可以精简写成<code>rang(10)</code>, 等同于区间<code>[0, 10)</code>的数组.</p>

<p><code>for</code>语句后同样可以带<code>else</code>语句，使用和<code>while</code>里一致。</p>

<hr />

<p>可以看到控制语句后面都可以携带<code>else</code>语句。有一种查找的用法，</p>

<pre><code>import random

m = random.randint(5, 15)

for i in range(10):
    if i == m:
        print(&quot;find %d&quot; % m)
        break
else:
    print(&quot;can't find %d&quot; % m)
</code></pre>

<h1 id="三-数据结构">三、数据结构</h1>

<h2 id="3-1-列表-list">3.1 列表 - list</h2>

<ul>
<li>列表有序，是一种序列</li>
<li>列表可变长度，可通过<code>list</code>的相关操作对列表进行增删等操作</li>
<li>列表数据类型可不同，即并不要求所有列表元素都是同一数据类型</li>
<li>列表用中括号表示</li>
</ul>

<p><strong>列表提供的方法列表</strong>
(通过<code>dir(list)</code>可查看到)</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>list.append(obj)</code></td>
<td>在列表末尾添加新的对象</td>
</tr>

<tr>
<td><code>list.count(obj)</code></td>
<td>统计某个元素在列表中出现的次数</td>
</tr>

<tr>
<td><code>list.extend(seq)</code></td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>

<tr>
<td><code>list.index(obj)</code></td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>

<tr>
<td><code>list.insert(index, obj)</code></td>
<td>将对象插入列表</td>
</tr>

<tr>
<td><code>list.pop(obj=list[-1])</code></td>
<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>

<tr>
<td><code>list.remove(obj)</code></td>
<td>移除列表中某个值的第一个匹配项</td>
</tr>

<tr>
<td><code>list.reverse()</code></td>
<td>反向列表中元素</td>
</tr>

<tr>
<td><code>list.sort([func])</code></td>
<td>对原列表进行排序</td>
</tr>
</tbody>
</table>

<p><strong>1. 列表初始化及遍历</strong></p>

<pre><code># 初始化列表
fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]

# 默认遍历列表。默认只有一个参数接收遍历的值。用于按`{VAL}`遍历。该参数标识列表的值。
for val in fruits:
    print(val)

# 根据长度来遍历。用于按`{KEY}`遍历
for idx in range(len(fruits)):
    print(fruits[idx])

# 按索引 - 值遍历，也可用于字典。用于按`{KEY - VAL}`遍历
for idx, val in enumerate(fruits):
    print(idx, val)
</code></pre>

<p><strong>2. 合并数据</strong></p>

<pre><code># 直接在原列表后面追加数据。可以是任何类型。
fruits.append(&quot;pear&quot;)
print(fruits) # output: ['apple', 'orange', 'banana', 'grape', 'pear']

# 在list后扩展数据，接收一个list，展平的方式追加到原列表后面
fruits.extend([&quot;peach&quot;, &quot;strawberry&quot;])
print(fruits) # output: ['apple', 'orange', 'banana', 'grape', 'pear', 'peach', 'strawberry']

# 也可用加号来合并两个列表
fruits + [&quot;mango&quot;] # mango追加到fruits数据后面

# 删除数据的3中方法
fruits.pop(2)
furits.remove(&quot;banana&quot;)
del fruits[2]
</code></pre>

<p><strong>3. 健壮性判断</strong></p>

<pre><code># 判断值是否在列表中(in 与 not in)
if &quot;strawberry&quot; in fruits:
    print(&quot;strawberry is in frutis&quot;) # output: strawberry is in frutis
else:
    print(&quot;strawberry is not in frutis&quot;)

# 类型判断
if isinstance(fruits, list):
    print(&quot;fruits is a list&quot;)

# 强制类型转换
&gt;&gt;&gt; x = &quot;Hello Python&quot;
&gt;&gt;&gt; list(x)
['H', 'e', 'l', 'l', 'o', ' ', 'P', 'y', 't', 'h', 'o', 'n']

# 判断是否为空
if not fruits:
    print(&quot;fruits is empty&quot;)

if len(fruits) == 0:
    print(fruits is empty)
</code></pre>

<h2 id="3-2-元祖-tuple">3.2 元祖 - tuple</h2>

<ul>
<li>元祖有序，也是一种序列</li>
<li>元祖一旦初始化不可修改</li>
<li>元祖数据类型也可不同</li>
<li>元祖用圆括号表示</li>
<li>元祖的访问和遍历同列表</li>
</ul>

<p><strong>元祖提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>tuple.count(obj)</code></td>
<td>统计某个元素在元祖中出现的次数</td>
</tr>

<tr>
<td><code>tuple.index(obj)</code></td>
<td>从元祖中找出某个值第一个匹配项的索引位置</td>
</tr>
</tbody>
</table>

<p><strong>1. 元祖初始化</strong></p>

<pre><code># 初始化元祖。只有1个元素时最后携带逗号
fruits = (&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;)

# 和列表一致，按索引的方式进行访问
print(fruits[0])

# 遍历元祖
for val in fruits:
    print(val)
</code></pre>

<h2 id="3-3-字典-dict">3.3 字典 - dict</h2>

<ul>
<li>按<code>键-值</code>对的方式初始化，相同的键会覆盖，用大括号表示</li>
<li>字典无序</li>
</ul>

<p><strong>字典提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>dict.clear()</code></td>
<td>清空字典</td>
</tr>

<tr>
<td><code>dict.get(k[,d])</code></td>
<td>D[k] if k in D, else d.  d defaults to None.</td>
</tr>

<tr>
<td><code>dict.has_key(k)</code></td>
<td>True if D has a key k, else False</td>
</tr>

<tr>
<td><code>dict.items()</code></td>
<td>list of D&rsquo;s (key, value) pairs, as 2-tuples</td>
</tr>

<tr>
<td><code>dict.keys()</code></td>
<td>list of D&rsquo;s keys</td>
</tr>

<tr>
<td><code>dict.pop(k, d)</code></td>
<td>remove specified key and return the corresponding value.If key is not found, d is returned if given, otherwise KeyError is raised</td>
</tr>

<tr>
<td><code>dict.update(obj)</code></td>
<td>合并两个字典</td>
</tr>
</tbody>
</table>

<p><strong>1. 字典初始化及遍历</strong></p>

<pre><code># 初始化字典方式一
fruits = {&quot;apple&quot;: 1, &quot;orange&quot;: 2, &quot;banana&quot;: 3}
# 初始化字典方式二
fruits = dict(apple = 1, orange = 2, banana = 3)

# 按KEY遍历
for idx in fruits:
    print(fruits[idx])

# 判断键是否在字典中
if &quot;grape&quot; in fruits:
    print(fruits[&quot;grape&quot;])
else:
    fruits[&quot;grape&quot;] = 4
# 判断键是否在字段中
if fruits.has_key(&quot;apple&quot;):
    print(fruits[&quot;apple&quot;])

# 按KEY - VALUE遍历
for idx, val in fruits.items():
    print(idx, val)
</code></pre>

<p><strong>2. 字典操作</strong></p>

<p>批量更新字典里的内容。</p>

<pre><code>fruits = dict(apple = 1, orange = 2, banana = 3)
fruits.update(cherry = 4)
# {'orange': 2, 'cherry': 4, 'banana': 3, 'apple': 1}

fruits.update({&quot;mango&quot;: 5})
# {'orange': 2, 'cherry': 4, 'mango': 5, 'banana': 3, 'apple': 1}

fruits.keys() # ['orange', 'cherry', 'mango', 'banana', 'apple']

# 删除数据的3中方法
del fruits[&quot;apple&quot;]
fruits.pop(&quot;banana&quot;)

# 清空字典
fruits.clear()
</code></pre>

<h2 id="3-4-集合-set">3.4 集合 - set</h2>

<ul>
<li>集合里的VALUE可以是不同的类型，相同数据会<code>去重</code>。</li>
<li>集合<code>无序</code></li>
</ul>

<p><strong>集合提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>set.add(obj)</code></td>
<td>往集合里添加元素</td>
</tr>

<tr>
<td><code>set.update(obj)</code></td>
<td>更新合并集合</td>
</tr>

<tr>
<td><code>set.discard(obj)</code></td>
<td>丢弃一个元素</td>
</tr>

<tr>
<td><code>set.remove(obj)</code></td>
<td>移除一个元素</td>
</tr>

<tr>
<td><code>set.pop()</code></td>
<td>从集合中弹出一个元素</td>
</tr>

<tr>
<td><code>set.clear()</code></td>
<td>清空一个集合</td>
</tr>

<tr>
<td>-</td>
<td>更多交叉并补方法</td>
</tr>
</tbody>
</table>

<p><strong>1. 集合初始化</strong></p>

<pre><code># 可变集合set初始化 - 初始化之后在进行赋值
fruits = set()
fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 直接创建
fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 通过列表转换
fruits = set([&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;])
print(fruits)

# 通过字典转换
fruits = set({&quot;apple&quot;:1, &quot;orange&quot;:2, &quot;banana&quot;:3}) # set(['orange', 'apple', 'banana'])


# 不可变集合用frozenset表示
websites = frozenset([&quot;qq.com&quot;, &quot;weibo.com&quot;])
</code></pre>

<p>集合分为可变集合(<code>set</code>)和不可变集合(<code>frozenset</code>)。针对可变集合可以往集合里<strong>添加元素</strong>。</p>

<pre><code>fruits = {&quot;apple&quot;, &quot;orange&quot;}
fruits.add(&quot;banana&quot;) # set(['orange', 'apple', 'banana'])

fruits.update({&quot;cherry&quot;}) # set(['orange', 'cherry', 'apple', 'banana'])

fruits.update(&quot;grape&quot;) # set(['a', 'e', 'apple', 'g', 'cherry', 'p', 'r', 'orange', 'banana'])

</code></pre>

<p><strong>移除元素</strong></p>

<pre><code>fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 移除不存在的元素不会报错
fruits.discard(&quot;test&quot;) 

# 移除不存在的元素会报错
fruits.remove(&quot;apple&quot;) 

# 弹出一个元素，集合为空时会报错
fruits.pop()

# 清空集合
fruits.clear()
</code></pre>

<p><strong>2. 集合的交叉并补等操作</strong></p>

<p>pass</p>

<h1 id="四-类型总结">四、类型总结</h1>

<h2 id="4-1-类型对比">4.1 类型对比</h2>

<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>序列</th>
<th>可变类型</th>
<th>传引用</th>
<th>获取</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>数值类型</code></td>
<td><code>i=1</code></td>
<td>-</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>字符串</code></td>
<td><code>str=&quot;Hello&quot;</code></td>
<td>是</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>list</code></td>
<td><code>[]</code></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>索引</td>
</tr>

<tr>
<td><code>dict</code></td>
<td><code>{}</code></td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>键</td>
</tr>

<tr>
<td><code>set</code></td>
<td><code>set()</code></td>
<td>否</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>tuple</code></td>
<td><code>()</code></td>
<td>是</td>
<td>否</td>
<td>-</td>
<td>索引</td>
</tr>
</tbody>
</table>

<p>列表、元组和字符串都是序列。字符串是字符的序列，列表和元祖是任意类型的序列。序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。</p>

<pre><code>fruits = &quot;apple&quot;

# 索引操作
print(fruits[1])

# 切片操作
print(fruits[1:-1])
print(fruits[1:])
print(fruits[:-1])
print(fruits[:])
</code></pre>

<h2 id="4-2-类型转换">4.2 类型转换</h2>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>

<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>

<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>

<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>

<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>

<tr>
<td>set(s)</td>
<td>将序列 s 转换为一个集合</td>
</tr>
</tbody>
</table>

<h1 id="五-函数">五、函数</h1>

<h2 id="5-1-函数定义">5.1 函数定义</h2>

<p><strong>1. 常规函数</strong></p>

<p>定义一个空函数，由于没有花括号表示代码块，针对空的代码块可以用pass占位。</p>

<pre><code>def func(x, y):
    pass
</code></pre>

<p><strong>2. 匿名函数</strong></p>

<p>函数定义：<code>lambda 参数: 表达式</code></p>

<pre><code>f = lambda x: x*x
print(f(2))
print((lambda x: x*x)(3))
</code></pre>

<p><strong>3. 闭包函数</strong></p>

<p><code>pass</code></p>

<h2 id="5-2-函数参数-可变参数与关键字参数">5.2 函数参数 - 可变参数与关键字参数</h2>

<p><code>python</code>的参数传入确实是相当的方便，参数传入非常灵活。但可也可能会导致根据参数无法清楚的表达函数行为。</p>

<pre><code>def func(x, y = 1, *args, **kwargs):
    print(type(args))
    print(type(kwargs))
    print(locals())

args = [1, 2]
kwargs = {&quot;param&quot;: &quot;web&quot;}

func(1, 2, 3, '4', param=&quot;web&quot;)
# &lt;type 'tuple'&gt;
# &lt;type 'dict'&gt;
# {'y': 2, 'x': 1, 'args': (3, '4'), 'kwargs': {'param': 'web'}}

func(1, 2, *args, **kwargs)
# &lt;type 'tuple'&gt;
# &lt;type 'dict'&gt;
# {'y': 2, 'x': 1, 'args': (1, 2), 'kwargs': {'param': 'web'}}
</code></pre>

<ul>
<li>支持设置默认参数</li>
<li>支持可变参数<code>*args</code>。函数接收到的数据类型是元祖。调用时可以以展平的方式传入，或者以列表、元祖的解引用的方式传入。</li>
<li>支持关键字参数<code>**kwargs</code>。函数接收到的数据类型是字典。</li>
</ul>

<h2 id="5-3-函数返回">5.3 函数返回</h2>

<p><strong>1. 多返回值</strong></p>

<pre><code>def func(x, y = 1):
    return x,y

x = func(1)

print(type(x))
print(x)

# &lt;type 'tuple'&gt;
# (1, 1)


x, _ = func(1)
print(type(x))
print(x)

# &lt;type 'int'&gt;
# 1
</code></pre>

<p><code>python</code>支持多个返回值，多个返回值实际返回的是一个元祖。多个参数时用一个参数接收时为元祖，用多个参数时可以直接将元祖解开得到具体的数据类型。</p>

<p><strong>2. 返回对象</strong></p>

<p>返回一个匿名函数。</p>

<pre><code>def func(x, y = 1):
    # lambda 参数: 表达式
    return lambda t: x+y if t == 1 else x*y

x = func(2, 3)
print(x(1))
print(type(x))

# 5
# &lt;type 'function'&gt;
</code></pre>

<h2 id="5-4-函数调用">5.4 函数调用</h2>

<p><code>python</code>中<strong>数字、字符、元组等不可变对象类型都属于值传递，而字典和列表等可变对象类型属于引用传递。</strong>对于可变对象意味着函数内部可以修改实参的值。</p>

<pre><code>import random

def func(x):
    x.append(random.randint(1, 100))
    print(x)

p = []
func(p)
func(p)
print(p)
# 打印[85, 86]，可见函数内部对p的修改直接影响了原有的值.
</code></pre>

<h2 id="5-5-函数装饰器">5.5 函数装饰器</h2>

<p><code>pass</code></p>

<h1 id="六-类-class">六、类 - Class</h1>

<h2 id="6-1-类定义">6.1 类定义</h2>

<pre><code>class Test(object):

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def sum(self):
        return self.x + self.y


t = Test(1, 2)
print(t.sum())
</code></pre>

<h2 id="6-2-包与导入">6.2 包与导入</h2>

<h1 id="七-错误和异常">七、错误和异常</h1>

<pre><code>try:
    t = Test(1, 'b')
    print(t.sum())
except (TypeError, NameError) as err:
    print(err)
except Exception as e:
    print(e)
else:
    raise Exception(&quot;throw exception&quot;)
</code></pre>

<h1 id="八-高级用法">八、高级用法</h1>

<h2 id="8-1-三元表达式">8.1 三元表达式</h2>

<p><code>[on true] if [expression] else [on false]</code></p>

<p>等价于：</p>

<pre><code>if [expression]:
    [on true]
else:
    [on false]
</code></pre>

<p>示例：</p>

<pre><code>$ import random

$ x = True if random.randint(0, 10) &gt; 5 else False
</code></pre>

<h2 id="8-2-推导式">8.2. 推导式</h2>

<p>下面是一个列表推导式，用来快速创建一个列表。可以分为列表推导式，字典推导式和集合推导式。</p>

<pre><code>[ expression for x in X [if condition]
             for y in Y [if condition]
             ...
             for n in N [if condition] ]
</code></pre>

<p>相当于：</p>

<pre><code>L = []
for x i X:
    [if condition]:
        for y in Y:
            [if condition]:
                L.append(x, y)

</code></pre>

<p>示例：</p>

<pre><code># 列表推导式
$ L = [x*y for x in range(1, 5) for y in range(6, 10) if y &gt; 8]
# [9, 18, 27, 36]

# 字典推导式
$ L = {x: y for x in range(1, 5) for y in range(6, 10) if y &gt; 8}
# {1: 9, 2: 9, 3: 9, 4: 9}

# 集合推导式
$ L = {x * y for x in range(1, 5) for y in range(6, 10) if y &gt; 8}
# set([9, 18, 27, 36])
</code></pre>

<div class="eof">-- EOF --</div>
<div class="eof_arrow">
    <a href="/"><img src="/static/img/arrow-back.png" style="width:25px;height:25px;" /></a>
</div>
<div class="eof_tag">
    发表于：
    <code style="border:0px;background:none;"><a href="/2015-12.html">2015-12-25 00:22</a></code>
</div>
<div class="eof_tag">
    标签：
    <code style="border:0px;background:none;"><a href="/tag/python.html">Python</a></code>
</div>

<div id="disqus_thread" style="margin-bottom:35px;"></div>
<script>

var disqus_config = function () {
    this.page.url = "http://itopic.org/python-language.html";
    this.page.identifier = "python-language";
};

setTimeout(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://itopic.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
}, 3000);

</script>

<div id="top"><a href="#"><img src="/static/img/arrow-top.png" style="width:40px;height:40px;" /></a></div>
<script>
ready(fn);
function ready(fn){  
    if(document.addEventListener){
        document.addEventListener('DOMContentLoaded',function(){
            document.removeEventListener('DOMContentLoaded',arguments.callee,false);  
            fn();
        },false);
    } else if(document.attachEvent) {
        document.attachEvent('onreadystatechange',function(){
            if(document.readyState=='complete'){
                document.detachEvent('onreadystatechange',arguments.callee);  
                fn();
            }
        });
    }  
}  
function fn(){
    if(document.getElementsByTagName("nav")[0].innerText == "") {
        document.getElementsByTagName("body")[0].style.marginLeft = "0";
    }
}
</script>
</body>
</html>