<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Nginx+Lua入门知识 - 老彭的博客</title>
    <link rel="stylesheet" href="/static/css/markdown.css">
</head>
<body>
<h1 class="title">Nginx+Lua入门知识</h1>

<a href="/"><img src="/static/img/arrow-back.png" class="title_arrow_back" /></a>

<nav>
<ul>
<li><a href="#hello-lua">Hello Lua</a>
<ul>
<li><a href="#content-by-lua">content_by_lua</a></li>
<li><a href="#content-by-lua-file">content_by_lua_file</a></li>
</ul></li>
<li><a href="#nginx常用参数获取">Nginx常用参数获取</a></li>
<li><a href="#获取md5示例">获取MD5示例</a></li>
</ul>
</nav>

<blockquote>
<p>OpenResty （也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx核心，很多的常用的第三方模块，以及它们的大多数依赖项。</p>

<p>通过众多进行良好设计的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用。</p>

<p>OpenResty 致力于将你的服务器端应用完全运行于 Nginx 服务器中，充分利用 Nginx 的事件模型来进行非阻塞 I/O 通信。不仅仅是和 HTTP 客户端间的网络通信是非阻塞的，与MySQL、PostgreSQL、Memcached、以及 Redis 等众多远方后端之间的网络通信也是非阻塞的。</p>

<p>因为 OpenResty 软件包的维护者也是其中打包的许多 Nginx 模块的作者，所以 OpenResty 可以确保所包含的所有组件可以可靠地协同工作。</p>
</blockquote>

<p>可直接通过官网安装，官网地址：<a href="http://openresty.org/">http://openresty.org/</a></p>

<blockquote>
<p>lua for windows其实是一整套Lua的开发环境.Lua for Windows 为 Windows 系统下提供了 Lua 脚本语言的开发和运行环境。Lua 是一个小巧的脚本语言。作者是巴西人。该语言的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>

<p>Lua脚本可以很容易的被C/C++代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用。不仅仅作为扩展脚本，也可以作为普通的配置文件，代替XML,Ini等文件格式，并且更容易理解和维护。</p>

<p>Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。
一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。</p>
</blockquote>

<p>Win下载地址：<a href="http://code.google.com/p/luaforwindows/">http://code.google.com/p/luaforwindows/</a></p>

<h1 id="hello-lua">Hello Lua</h1>

<p>nginx通过content_by_lua和content_by_lua_file来嵌入lua脚本。</p>

<h2 id="content-by-lua">content_by_lua</h2>

<p>修改nginx配置文件nginx.conf</p>

<pre><code>location /hellolua {
    content_by_lua '
        ngx.header.content_type = &quot;text/html&quot;;
        ngx.say(&quot;Hello Lua.&quot;);
    ';
}
</code></pre>

<p>重启nginx访问 <a href="http://localhost//hellolua">http://localhost//hellolua</a> 应该可以看到 Hello Lua.</p>

<h2 id="content-by-lua-file">content_by_lua_file</h2>

<pre><code>location /demo {
    lua_code_cache off;
    content_by_lua_file lua_script/demo.lua;
}
</code></pre>

<p>lua_code_cache表示关掉缓存，缓存关掉的情况下修改lua脚本不需要重启nginx。content_by_lua_file指定脚本路径。此处为相对路径，相对于nginx根目录，然后写上下面lua脚本</p>

<pre><code>-- filename:demo.lua
ngx.header.content_type = &quot;text/html&quot;
ngx.say(&quot;Hello Lua Demo.&quot;)
</code></pre>

<p>重启Nginx，关掉lua_code_cache后nginx会有个alert。</p>

<p><code>nginx: [alert] lua_code_cache is off; this will hurt performance in ./conf/nginx.conf:56</code></p>

<p>访问 <a href="http://localhost/demo">http://localhost/demo</a> 则可以看到 Hello Lua Demo.</p>

<h1 id="nginx常用参数获取">Nginx常用参数获取</h1>

<pre><code>ngx.header.content_type = &quot;text/html&quot;
ngx.header.PowerBy = &quot;Lua&quot;
-- 请求头table
for k, v in pairs(ngx.req.get_headers()) do
    ngx.say(k, &quot;: &quot;, v)
end
 
-- 请求方法 GET、POST等
ngx.say(&quot;METHOD:&quot; .. ngx.var.request_method)
 
-- 获取GET参数
for k, v in pairs(ngx.req.get_uri_args()) do
    ngx.say(k, &quot;:&quot;, v)
end
 
 
-- 获取POST参数
ngx.req.read_body()
for k, v in pairs(ngx.req.get_post_args()) do
    ngx.say(k, &quot;:&quot;, v)
end
 
-- HTTP版本
ngx.say(ngx.req.http_version())
 
-- 未解析的请求头字符串
ngx.say(ngx.req.raw_header())  
 
-- 未解析的BODY字符串
ngx.print(ngx.req.get_body_data())
 
-- ngx.exit(400)
-- ngx.redirect(&quot;/&quot;, 200)
</code></pre>

<h1 id="获取md5示例">获取MD5示例</h1>

<p>下面看个小例子，生成字符串的md5值。</p>

<pre><code>ngx.header.content_type = &quot;text/html&quot;
local resty_md5 = require &quot;resty.md5&quot;
local  md5 = resty_md5:new()
 
local s = &quot;Hello Lua.&quot;
md5:update(s)
local str = require &quot;resty.string&quot;
ngx.say(str.to_hex(md5:final()))
 
ngx.say(ngx.md5(s))
</code></pre>

<div class="eof">-- EOF --</div>
<div class="eof_arrow">
    <a href="/"><img src="/static/img/arrow-back.png" style="width:25px;height:25px;" /></a>
</div>

<div class="eof_tag">
    发表于：
    <code style="border:0px;background:none;"><a href="/2016-01.html">2016-01-01 16:15</a></code>
</div>
<div class="eof_tag">
    标签：
    <code style="border:0px;background:none;"><a href="/tag/lua.html">Lua</a></code>
</div>

<div id="footer">
    <ul>
        <li>
            <b>Github地址</b>：<a href="https://github.com/pengbotao/itopic.go/blob/master/posts/lua/Nginx+Lua入门知识.md">https://github.com/pengbotao/itopic.go/blob/master/posts/lua/Nginx+Lua入门知识.md</a>
        <li>
        <li>
            @2013-2020 老彭的博客&nbsp;[Hosted by <a href="javascript:;" style="font-weight: bold" target="_blank">Github Pages</a>]
        </li>
    </ul>
</div>

<div id="top"><a href="#"><img src="/static/img/arrow-top.png" style="width:40px;height:40px;" /></a></div>
<script>
ready(fn);
function ready(fn){  
    if(document.addEventListener){
        document.addEventListener('DOMContentLoaded',function(){
            document.removeEventListener('DOMContentLoaded',arguments.callee,false);  
            fn();
        },false);
    } else if(document.attachEvent) {
        document.attachEvent('onreadystatechange',function(){
            if(document.readyState=='complete'){
                document.detachEvent('onreadystatechange',arguments.callee);  
                fn();
            }
        });
    }  
}  
function fn(){
    if(document.getElementsByTagName("nav")[0].innerText == "") {
        document.getElementsByTagName("body")[0].style.marginLeft = "0";
    }
}
</script>
</body>
</html>